generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider  = "postgresql"
    url       = env("DATABASE_URL")
    directUrl = env("DATABASE_URL_UNPOOLED")
}

model User {
    id        Int       @id @default(autoincrement())
    firstName String
    lastName  String
    email     String    @unique
    password  String
    role      UserRole  @default(USER)
    verified  DateTime?

    provider   String? // e.g., "google", "github" for OAuth users
    providerId String? // e.g., OAuth provider user ID

    createdAt        DateTime          @default(now())
    updatedAt        DateTime          @updatedAt
    carts            Cart?
    orders           Order[]
    verificationCode VerificationCode?
}

model Layout {
    id        String     @id @default(cuid())
    name      String     @unique // "ANSI", "ISO", "JIS", "60%", "TKL", "Full-size"
    keyboards Keyboard[] // one to many

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model Keyboard {
    id                 String   @id @default(cuid())
    name               String
    basePrice          Decimal  @db.Decimal(10, 2)
    discountPercentage Int      @default(0) // (0-100)
    layoutId           String
    layout             Layout   @relation(fields: [layoutId], references: [id]) // many to one
    description        String?  @db.Text
    createdAt          DateTime @default(now())
    updatedAt          DateTime @updatedAt

    // Relations
    switches      Switch[] // Implicit many-to-many
    colorVariants ColorVariant[]
    cartItems     CartItem[]

    @@index([name])
    @@index([layoutId])
}

model Switch {
    id            String   @id @default(cuid())
    name          String   @unique // e.g., "Cherry MX Red", "Gateron Brown"
    type          String // e.g., "Linear", "Tactile", "Clicky"
    priceModifier Decimal  @db.Decimal(10, 2) // Additional cost for this switch
    inStock       Boolean  @default(true)
    description   String?  @db.Text
    createdAt     DateTime @default(now())
    updatedAt     DateTime @updatedAt

    // Relations
    keyboards Keyboard[] // Implicit many-to-many
    cartItems CartItem[]

    @@index([name])
}

model ColorVariant {
    id         String   @id @default(cuid())
    keyboardId String
    colorName  String // e.g., "Midnight Black", "Ocean Blue", "Rose Gold"
    colorHex   String // e.g., "#000000" for visual representation
    imageUrl   String // Primary image URL for this color
    isDefault  Boolean  @default(false) // Which color is shown by default
    sortOrder  Int      @default(0) // For maintaining color order in UI
    inStock    Boolean  @default(true)
    createdAt  DateTime @default(now())
    updatedAt  DateTime @updatedAt

    // Relations
    keyboard         Keyboard          @relation(fields: [keyboardId], references: [id], onDelete: Cascade)
    additionalImages AdditionalImage[]
    cartItems        CartItem[]

    @@unique([keyboardId, colorName])
    @@index([keyboardId])
    @@index([isDefault])
}

// Optional: Additional images per color variant (multiple angles, close-ups, etc.)
model AdditionalImage {
    id             String   @id @default(cuid())
    colorVariantId String
    imageUrl       String
    altText        String?
    sortOrder      Int      @default(0)
    createdAt      DateTime @default(now())

    // Relations
    colorVariant ColorVariant @relation(fields: [colorVariantId], references: [id], onDelete: Cascade)

    @@index([colorVariantId])
}

model Cart {
    id          Int     @id @default(autoincrement())
    user        User?   @relation(fields: [userId], references: [id])
    userId      Int?    @unique
    token       String  @unique
    totalAmount Decimal @default(0) @db.Decimal(10, 2)

    createdAt DateTime   @default(now())
    updatedAt DateTime   @updatedAt
    cartItems CartItem[]
}

model CartItem {
    id Int @id @default(autoincrement())

    cart   Cart @relation(fields: [cartId], references: [id], onDelete: Cascade)
    cartId Int

    keyboard   Keyboard @relation(fields: [keyboardId], references: [id])
    keyboardId String

    colorVariant   ColorVariant @relation(fields: [colorVariantId], references: [id])
    colorVariantId String

    switch   Switch @relation(fields: [switchId], references: [id])
    switchId String

    quantity Int @default(1)

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([cartId, keyboardId, colorVariantId, switchId])
    @@index([cartId]) // For fetching all items in a cart
}

model Order {
    id String @id @default(cuid())

    user   User? @relation(fields: [userId], references: [id])
    userId Int?

    token String? // For guest orders

    // Order status
    status        OrderStatus   @default(PENDING)
    // Payment information
    paymentStatus PaymentStatus @default(PENDING)
    paymentId     String?

    // Items stored as JSON
    items Json

    // Pricing
    totalAmount Decimal @db.Decimal(10, 2)

    // Shipping information
    firstName            String
    lastName             String
    email                String
    phone                String
    address              String
    city                 String
    zipCode              String
    deliveryInstructions String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([userId])
    @@index([status])
    @@index([createdAt])
}

model VerificationCode {
    id Int @id @default(autoincrement())

    user   User @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId Int  @unique

    code String // The verification code

    createdAt DateTime @default(now())
    
    @@unique([userId, code])
}

enum OrderStatus {
    PENDING // Order created, waiting for payment
    CONFIRMED // Payment received, processing
    PROCESSING // Being prepared
    SHIPPED // On the way
    DELIVERED // Completed
    CANCELLED // Cancelled by user or admin
    REFUNDED // Refunded
}

enum PaymentStatus {
    PENDING // Waiting for payment
    SUCCEEDED // Payment successful
    FAILED // Payment failed
    REFUNDED // Payment refunded
}

enum UserRole {
    USER
    ADMIN
}
